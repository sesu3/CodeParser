package tmpj.db;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.Arrays;
import java.util.Iterator;

import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.TypeDeclaration;

import tmpj.core.ASTTool;
import tmpj.core.object.Revision;
import tmpj.core.object.Variable;

public class ParserDBHandler implements DBHandler
{
	private Connection connection;
	private int revId=-1;
	private int fileId=-1;

	public ParserDBHandler(String user,String password,String dbName)
			throws InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException
	{
		Class.forName("com.mysql.jdbc.Driver").newInstance();
		String url="jdbc:mysql://localhost";
		this.connection=DriverManager.getConnection(url, user, password);
		this.createDatabase(dbName);
	}

	public boolean createDatabase(String dbName) throws SQLException
	{
		if(!dbName.matches("[a-zA-Z][a-zA-Z0-9_]*")){
			return false;
		}
		Statement stmt = connection.createStatement();
		stmt.execute("create database "+dbName);
		stmt.execute("use "+dbName);
		stmt.execute(CREATE_TABLE_REVISION);
		stmt.execute(CREATE_TABLE_FILE);
		stmt.execute(CREATE_TABLE_TYPE);
		stmt.execute(CREATE_TABLE_FIELD);
		stmt.execute(CREATE_TABLE_METHOD);
		stmt.execute(CREATE_TABLE_ARGUMENT);
		stmt.close();
		return true;
	}
	
	@Override
	public void register(Revision rev) throws SQLException
	{
		PreparedStatement pstmt=connection.prepareStatement(SQL_INSERT_REVISION,Statement.RETURN_GENERATED_KEYS);
		pstmt.setString(1, rev.getHash());
		pstmt.setString(2, rev.getAuthorName());
		pstmt.setString(3, rev.getAuthorMail());
		if(rev.getAuthorDate()!=null){
			pstmt.setTimestamp(4,new Timestamp(Long.parseLong(rev.getAuthorDate())*1000));
		}else{
			pstmt.setTimestamp(4,null);
		}
		pstmt.setString(5, rev.getCommitterName());
		pstmt.setString(6, rev.getCommitterMail());
		if(rev.getCommitterDate()!=null){
			pstmt.setTimestamp(7,new Timestamp(Long.parseLong(rev.getCommitterDate())*1000));
		}else{
			pstmt.setTimestamp(7,null);
		}
		pstmt.setString(8, rev.getMessage());
		pstmt.execute();
		ResultSet rs=pstmt.getGeneratedKeys();
		boolean isExist=rs.next();
		assert isExist:"revision Id no returened";
		this.revId=rs.getInt(1);
		rs.close();
		pstmt.close();
	}

	@Override
	public void register(String filePath, String status) throws SQLException
	{
		PreparedStatement pstmt=
			connection.prepareStatement(SQL_INSERT_FILE,Statement.RETURN_GENERATED_KEYS);
		pstmt.setInt(1,this.revId);
		pstmt.setString(2,filePath);
		pstmt.setString(3,status);
		pstmt.execute();
		ResultSet rs=pstmt.getGeneratedKeys();
		boolean isExist=rs.next();
		assert isExist:"file Id no returned";
		this.fileId=rs.getInt(1);
		rs.close();
		pstmt.close();
	}

	@Override
	public void register(TypeDeclaration node) throws SQLException
	{
		int flags=node.getModifiers();
		PreparedStatement pstmt=
				connection.prepareStatement(SQL_INSERT_TYPE,Statement.RETURN_GENERATED_KEYS);
		pstmt.setInt(1, this.fileId);
		pstmt.setString(2, ASTTool.getFullyQualifiedClassName(node));
		pstmt.setBoolean(3, node.isInterface());
		pstmt.setString(4, ASTTool.getSuperclassType(node));
		pstmt.setString(5, ASTTool.getAccessModifier(node));
		pstmt.setBoolean(6, Modifier.isStatic(flags));
		pstmt.setBoolean(7, Modifier.isAbstract(flags));
		pstmt.setBoolean(8, Modifier.isFinal(flags));
		pstmt.setBoolean(9, Modifier.isStrictfp(flags));
		pstmt.setInt(10, ASTTool.getStartLineNumber(node));
		pstmt.setInt(11, ASTTool.getEndLineNumber(node));
		pstmt.execute();
		ResultSet rs=pstmt.getGeneratedKeys();
		boolean isExist=rs.next();
		assert isExist:"type Id no returned";
		int autoGeneratedTypeId=rs.getInt(1);
		rs.close();
		pstmt.close();
		pstmt=connection.prepareStatement(SQL_INSERT_FIELD);
		for(Iterator<Variable> iter=ASTTool.getFields(node).iterator();iter.hasNext();){
			Variable v=iter.next();
			pstmt.setInt(1, this.fileId);
			pstmt.setInt(2, autoGeneratedTypeId);
			pstmt.setString(3, v.getType());
			pstmt.setString(4, v.getName());
			pstmt.setString(5, ASTTool.getAccessModifier(v.getModifiers()));
			pstmt.setBoolean(6, Modifier.isFinal(v.getModifiers()));
			pstmt.setBoolean(7, Modifier.isTransient(v.getModifiers()));
			pstmt.setBoolean(8, Modifier.isVolatile(v.getModifiers()));
			pstmt.execute();
		}
		pstmt.close();
		for(Iterator<MethodDeclaration> iter=Arrays.asList(node.getMethods()).iterator();iter.hasNext();){
			register(iter.next(),autoGeneratedTypeId);
		}
	}

	public void register(MethodDeclaration node,int typeId) throws SQLException
	{
		int flags=node.getModifiers();
		PreparedStatement pstmt=
				connection.prepareStatement(SQL_INSERT_METHOD,Statement.RETURN_GENERATED_KEYS);
		pstmt.setInt(1, this.fileId);
		pstmt.setInt(2, typeId);
		pstmt.setString(3, ASTTool.getFullyQualifiedClassName(node));
		pstmt.setBoolean(4, node.isConstructor());
		pstmt.setString(5, ASTTool.getReturnType(node));
		pstmt.setString(6, ASTTool.getAccessModifier(node));
		pstmt.setBoolean(7, Modifier.isAbstract(flags));
		pstmt.setBoolean(8, Modifier.isStatic(flags));
		pstmt.setBoolean(9, Modifier.isFinal(flags));
		pstmt.setBoolean(10, Modifier.isSynchronized(flags));
		pstmt.setBoolean(11, Modifier.isNative(flags));
		pstmt.setBoolean(12, Modifier.isStrictfp(flags));
		pstmt.setInt(13, ASTTool.getStartLineNumber(node));
		pstmt.setInt(14, ASTTool.getEndLineNumber(node));
		pstmt.execute();
		ResultSet rs=pstmt.getGeneratedKeys();
		boolean isExist=rs.next();
		assert isExist:"method Id no returned";
		int autoGeneratedMethodId=rs.getInt(1);
		rs.close();
		pstmt.close();
		pstmt=connection.prepareStatement(SQL_INSERT_ARGUMENT);
		for(Iterator<SingleVariableDeclaration> iter=node.parameters().iterator();iter.hasNext();){
			SingleVariableDeclaration argument=iter.next();
			pstmt.setInt(1,autoGeneratedMethodId);
			pstmt.setString(2,argument.getType().toString());
			pstmt.setString(3,argument.getName().toString());
			pstmt.execute();
		}
		pstmt.close();
	}

	@Override
	protected void finalize() throws Throwable
	{
		try {
			super.finalize();
		} finally {
			if(connection!=null){
				connection.close();
			}
		}
	}

	private static final String CREATE_TABLE_REVISION=
			"create table revision("+
					"id integer primary key auto_increment,hash varchar(64) not null,"+
					"authorName text,authorMail text,authorDate datetime,"+
					"committerName text,committerMail text,committerDate datetime,"+
					"message text)";
	private static final String CREATE_TABLE_FILE=
			"create table file("+
					"id integer primary key auto_increment,revId int not null,"+
					"path text not null,status varchar(4) not null)";
	private static final String CREATE_TABLE_TYPE=
			"create table type("+
					"id integer primary key auto_increment,fileId integer not null,"+
					"FQCN text not null,isInterface boolean not null,super text not null,"+
					"access varchar(16) not null,isStatic boolean not null,"+
					"isAbstract boolean not null,isFinal boolean not null,isStrictfp boolean not null,"+
					"startLine integer not null,endLine integer not null)";
	private static final String CREATE_TABLE_FIELD=
			"create table field("+
					"id integer primary key auto_increment,fileId integer not null,typeId integer not null,"+
					"type text not null,name text not null,"+
					"access varchar(16) not null,isFinal boolean not null,"+
					"isTransient boolean not null,isVolatile boolean not null)";
	private static final String CREATE_TABLE_METHOD=
			"create table method("+
					"id integer primary key auto_increment,fileId integer not null,typeId integer not null,"+
					"name text not null,isConstructor boolean not null,returnType text not null,"+
					"access varchar(16) not null,isAbstract boolean not null,"+
					"isStatic boolean not null,isFinal boolean not null,isSynchronized boolean not null,"+
					"isNative boolean not null,isStrictfp boolean not null,"+
					"startLine integer not null,endLine integer not null)";
	private static final String CREATE_TABLE_ARGUMENT=
			"create table argument("+
					"id integer primary key auto_increment,methodId integer not null,"+
					"type text not null,name text not null)";
	
	private static final String SQL_INSERT_REVISION=
			"insert into revision ("+
					"hash,authorName,authorMail,authorDate,committerName,committerMail,committerDate,message"+
			") values (?,?,?,?,?,?,?,?)";
	private static final String SQL_INSERT_FILE="insert into file (revId,path,status) values (?,?,?)";
	private static final String SQL_INSERT_TYPE=
			"insert into type ("+
					"fileId,FQCN,isInterface,super,access,isStatic,isAbstract,isFinal,isStrictfp,startLine,endLine"+
			") values (?,?,?,?,?,?,?,?,?,?,?)";

	private static final String SQL_INSERT_FIELD=
			"insert into field (fileId,typeId,type,name,access,isFinal,isTransient,isVolatile) values (?,?,?,?,?,?,?,?)";
	private static final String SQL_INSERT_METHOD=
			"insert into method ("+
					"fileId,typeId,name,isConstructor,returnType,"+
					"access,isAbstract,isStatic,isFinal,isSynchronized,isNative,isStrictfp,startLine,endLine"+
			") values (?,?,?,?,?,?,?,?,?,?,?,?,?,?)";
	private static final String SQL_INSERT_ARGUMENT="insert into argument (methodId,type,name) values (?,?,?)";

	
}
