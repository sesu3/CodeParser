package codeparser.db;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.util.Arrays;
import java.util.Iterator;

import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Modifier;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.Type;
import org.eclipse.jdt.core.dom.TypeDeclaration;

import codeparser.core.ASTTool;
import codeparser.core.object.Revision;
import codeparser.core.object.Variable;

public class ParserDBHandler implements DBHandler
{
	private Connection connection;
	private int fileId=-1;

	public ParserDBHandler(String server,String user,String password,String dbName)
			throws InstantiationException, IllegalAccessException, ClassNotFoundException, SQLException
	{
		Class.forName("com.mysql.jdbc.Driver").newInstance();
		String url="jdbc:mysql://"+server;
		this.connection=DriverManager.getConnection(url, user, password);
		this.createDatabase(dbName);
	}

	public boolean createDatabase(String dbName) throws SQLException
	{
		if(!dbName.matches("[a-zA-Z][a-zA-Z_]*")){
			return false;
		}
		Statement stmt = this.connection.createStatement();
		stmt.execute("create database "+dbName);
		stmt.execute("use "+dbName);
		stmt.execute(CREATE_TABLE_REVISION);
		stmt.execute(CREATE_TABLE_FILE);
		stmt.execute(CREATE_TABLE_TYPE);
		stmt.execute(CREATE_TABLE_IMPLEMENTS);
		stmt.execute(CREATE_TABLE_FIELD);
		stmt.execute(CREATE_TABLE_METHOD);
		stmt.execute(CREATE_TABLE_THROWS);
		stmt.execute(CREATE_TABLE_ARGUMENT);
		stmt.execute(CREATE_TABLE_VARIABLE);
		stmt.close();
		return true;
	}
	
	@Override
	public void register(Revision rev) throws SQLException
	{
		String sql="insert into revision (hash,authorName,authorMail,authorDate,committerName,committerMail,committerDate,message) "+
				"values (?,?,?,?,?,?,?,?)";
		PreparedStatement pstmt=this.connection.prepareStatement(sql);
		pstmt.setString(1, rev.getHash());
		pstmt.setString(2, rev.getAuthorName());
		pstmt.setString(3, rev.getAuthorMail());
		pstmt.setTimestamp(4,new Timestamp(Long.parseLong(rev.getAuthorDate())*1000));
		pstmt.setString(5, rev.getCommitterName());
		pstmt.setString(6, rev.getCommitterMail());
		pstmt.setTimestamp(7,new Timestamp(Long.parseLong(rev.getCommitterDate())*1000));
		pstmt.setString(8, rev.getMessage());
		pstmt.execute();
		pstmt.close();
	}

	@Override
	public void register(String hash, String filePath, String status) throws SQLException
	{
		PreparedStatement pstmt=
			this.connection.prepareStatement("insert into file (hash,path,status) values (?,?,?)", 
					Statement.RETURN_GENERATED_KEYS);
		pstmt.setString(1,hash);
		pstmt.setString(2,filePath);
		pstmt.setString(3,status);
		pstmt.execute();
		ResultSet rs=pstmt.getGeneratedKeys();
		int autoGeneratedKey=-1;
		if(rs.next()){
			autoGeneratedKey=rs.getInt(1);
		}
		rs.close();
		pstmt.close();
		this.fileId=autoGeneratedKey;
	}

	@Override
	public void register(TypeDeclaration node) throws SQLException
	{
		int flags=node.getModifiers();
		PreparedStatement pstmt=
				this.connection.prepareStatement(
						"insert into type (fileId,FQCN,isInterface,super,access,static,abstract,final,strictfp,startLine,endLine) "+
						"values (?,?,?,?,?,?,?,?,?,?,?)",
						Statement.RETURN_GENERATED_KEYS);
		pstmt.setInt(1, this.fileId);
		pstmt.setString(2, ASTTool.getFullyQualifiedClassName(node));
		pstmt.setBoolean(3, node.isInterface());
		pstmt.setString(4, ASTTool.getSuperclassType(node));
		pstmt.setString(5, ASTTool.getAccessModifier(node));
		pstmt.setBoolean(6, Modifier.isStatic(flags));
		pstmt.setBoolean(7, Modifier.isAbstract(flags));
		pstmt.setBoolean(8, Modifier.isFinal(flags));
		pstmt.setBoolean(9, Modifier.isStrictfp(flags));
		pstmt.setInt(10, ASTTool.getStartLineNumber(node));
		pstmt.setInt(11, ASTTool.getEndLineNumber(node));
		pstmt.execute();
		ResultSet rs=pstmt.getGeneratedKeys();
		int autoGeneratedTypeId=-1;
		if(rs.next()){
			autoGeneratedTypeId=rs.getInt(1);
		}
		pstmt=this.connection.prepareStatement("insert into implements (typeId,type) values (?,?)");
		for(Iterator<Type> iter=node.superInterfaceTypes().iterator();iter.hasNext();){
			pstmt.setInt(1,autoGeneratedTypeId);
			pstmt.setString(2,iter.next().toString());
			pstmt.execute();
		}
		for(Iterator<Variable> iter=ASTTool.getFields(node).iterator();iter.hasNext();){
			Variable v=iter.next();
			pstmt=this.connection.prepareStatement(
					"insert into field (typeId,type,name,access,final,transient,volatile) values (?,?,?,?,?,?,?)");
			pstmt.setInt(1, autoGeneratedTypeId);
			pstmt.setString(2, v.getType());
			pstmt.setString(3, v.getName());
			pstmt.setString(4, ASTTool.getAccessModifier(v.getModifiers()));
			pstmt.setBoolean(5, Modifier.isFinal(v.getModifiers()));
			pstmt.setBoolean(6, Modifier.isTransient(v.getModifiers()));
			pstmt.setBoolean(7, Modifier.isVolatile(v.getModifiers()));
			pstmt.execute();
			
		}
		for(Iterator<MethodDeclaration> iter=Arrays.asList(node.getMethods()).iterator();iter.hasNext();){
			register(iter.next(),autoGeneratedTypeId);
		}
		rs.close();
		pstmt.close();
	}

	public void register(MethodDeclaration node,int typeId) throws SQLException
	{
		int flags=node.getModifiers();
		PreparedStatement pstmt=
				this.connection.prepareStatement(
						"insert into method (typeId,name,isConstructor,returnType,"+
						"access,abstract,static,final,synchronized,native,strictfp,startLine,endLine) "+
						"values (?,?,?,?,?,?,?,?,?,?,?,?,?)",
						Statement.RETURN_GENERATED_KEYS);
		pstmt.setInt(1, typeId);
		pstmt.setString(2, node.getName().toString());
		pstmt.setBoolean(3, node.isConstructor());
		pstmt.setString(4, ASTTool.getReturnType(node));
		pstmt.setString(5, ASTTool.getAccessModifier(node));
		pstmt.setBoolean(6, Modifier.isAbstract(flags));
		pstmt.setBoolean(7, Modifier.isStatic(flags));
		pstmt.setBoolean(8, Modifier.isFinal(flags));
		pstmt.setBoolean(9, Modifier.isSynchronized(flags));
		pstmt.setBoolean(10, Modifier.isNative(flags));
		pstmt.setBoolean(11, Modifier.isStrictfp(flags));
		pstmt.setInt(12, ASTTool.getStartLineNumber(node));
		pstmt.setInt(13, ASTTool.getEndLineNumber(node));
		pstmt.execute();
		ResultSet rs=pstmt.getGeneratedKeys();
		int autoGeneratedMethodId=-1;
		if(rs.next()){
			autoGeneratedMethodId=rs.getInt(1);
		}
		pstmt=this.connection.prepareStatement("insert into argument (methodId,type,name) values (?,?,?)");
		for(Iterator<SingleVariableDeclaration> iter=node.parameters().iterator();iter.hasNext();){
			SingleVariableDeclaration argument=iter.next();
			pstmt.setInt(1,autoGeneratedMethodId);
			pstmt.setString(2,argument.getType().toString());
			pstmt.setString(3,argument.getName().toString());
			pstmt.execute();
		}
		pstmt=this.connection.prepareStatement("insert into throws (methodId,type) values (?,?)");
		for(Iterator<Type> iter=node.thrownExceptionTypes().iterator();iter.hasNext();){
			pstmt.setInt(1,autoGeneratedMethodId);
			pstmt.setString(2,iter.next().toString());
			pstmt.execute();
		}
		pstmt=this.connection.prepareStatement("insert into variable (methodId,type,name) values (?,?,?)");
		for(Iterator<Variable> iter=ASTTool.getLocalVariables(node).iterator();iter.hasNext();){
			Variable v=iter.next();
			pstmt.setInt(1,autoGeneratedMethodId);
			pstmt.setString(2,v.getType());
			pstmt.setString(3,v.getName());
			pstmt.execute();
		}
		rs.close();
		pstmt.close();
	}

	@Override
	protected void finalize() throws Throwable
	{
		try {
			super.finalize();
		} finally {
			if(this.connection!=null){
				this.connection.close();
			}
		}
	}

	private static final String CREATE_TABLE_REVISION=
			"create table revision("+
					"hash varchar(64) primary key not null,"+
					"authorName text,authorMail text,authorDate datetime,"+
					"committerName text,committerMail text,committerDate datetime,"+
					"message text)";
	private static final String CREATE_TABLE_FILE=
			"create table file("+
					"id integer primary key auto_increment,hash varchar(64) not null,"+
					"path text not null,status varchar(4) not null)";
	private static final String CREATE_TABLE_TYPE=
			"create table type("+
					"id integer primary key auto_increment,fileId integer not null,"+
					"FQCN text not null,isInterface boolean not null,super text not null,"+
					"access varchar(16) not null,static boolean not null,"+
					"abstract boolean not null,final boolean not null,strictfp boolean not null,"+
					"startLine integer not null,endLine integer not null)";
	private static final String CREATE_TABLE_IMPLEMENTS=
			"create table implements("+
					"id integer primary key auto_increment,typeId integer not null,type text not null)";
	private static final String CREATE_TABLE_FIELD=
			"create table field("+
					"id integer primary key auto_increment,typeId integer not null,"+
					"type text not null,name text not null,"+
					"access varchar(16) not null,final boolean not null,"+
					"transient boolean not null,volatile boolean not null)";
	private static final String CREATE_TABLE_METHOD=
			"create table method("+
					"id integer primary key auto_increment,typeId integer not null,"+
					"name text not null,isConstructor boolean not null,returnType text not null,"+
					"access varchar(16) not null,abstract boolean not null,"+
					"static boolean not null,final boolean not null,synchronized boolean not null,"+
					"native boolean not null,strictfp boolean not null,"+
					"startLine integer not null,endLine integer not null)";
	private static final String CREATE_TABLE_THROWS=
			"create table throws("+
					"id integer primary key auto_increment,"+
					"methodId integer not null,type text not null)";
	private static final String CREATE_TABLE_ARGUMENT=
			"create table argument("+
					"id integer primary key auto_increment,methodId integer not null,"+
					"type text not null,name text not null)";
	private static final String CREATE_TABLE_VARIABLE=
			"create table variable("+
					"id integer primary key auto_increment,methodId integer not null,"+
					"type text not null,name text not null)";

}
